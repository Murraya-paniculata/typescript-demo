# 接口和类型的兼容性

## 扩展类型----接口
用于约束类、函数或对象的契约（标准）
1、接口约束对象
接口不出现在编译结果中
```
interface User {
    name: string,
    age: number,
    sayHello: () => void
}
```
2. 接口约束函数

**接口可以继承**
```
interface A {
    T1: string
}

interface B extends A {
    T2: number
}

interface C extends A, B {
    T3: string
}

let d: B = {
    T1: "123",
    T2: 123
}

let c: C = {
    T1: '123',
    T2: 1,
    T3: '123'
```
// 使用类型别名可以实现与以上接口的相似的继承效果，需要通过```&```,（交叉类型）

```
type Q = {
    T1: number
}

type Q1 = {
    T2: string
}

type Q3 = {
    T3: number
} & Q & Q1

let q: Q3 = {
    T1: 1,
    T2: '122',
    T3: 234
}
```

它们的区别
- 子接口不能覆盖父接口的成员（会报错）
- 类型别名用交叉类型会把相同成员的类型进行交叉

**readonly**
只读修饰符，修饰的目标无法改写; 它不在编译结果中

## 类型兼容性

B -> A 如果能完成赋值，则B和A类型兼容

基本类型： 完全匹配
对象： 鸭子辩形发法

类型断言
**as 关键字**
```
interface Duck {
    sound: "嘎嘎嘎"
    swin():void
}

let per = {
    name: '违章出鞥',
    sound: "嘎嘎嘎" as "嘎嘎嘎",
    age: 123,
    swin() {
        console.log(123);
    }
}

let duck: Duck = per;

// 但是这样直接字面量赋值会报错的
let duck: Duck = {
    name: '违章出鞥',
    sound: "嘎嘎嘎" as "嘎嘎嘎",
    age: 123,
    swin() {
        console.log(123);
    }
};

```

- 函数类型
1.关于函数的参数
传递给目标函数的参数可以少但是不能多

2.关于返回值
要求返回的必须返回且type必须匹配，不要求返回的时候，可以随便写

